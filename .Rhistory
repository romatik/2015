prepare_university_eair("N.5.1", dataset, "University of Padua, Italy")
prepare_university_eair <- function(x, course_dataset, university){
# function to prepare a dataset to use in EAIR paper
# x = name of the question
# course_dataset = dataset that needs to be prepared
# returns a dataset:
# universities with 10 or more respondents and answers to questions by respondents
questions_uni <- c("N.", "O.", "P.", "Q.") #first letters for questions about specific universities
x <- substr(x, 3, 5) #updating x to use it in a function. x in the beginning is used to make calls to functions consistent
#creating four datasets to merge them leter. Name of the university is used as an ID.
#### for paper: can add A.2.name.of.Erasmus.Mundus.master.course. to chunks and then use group_by on that variable to create other chunks
first_university <- course_dataset %>%
select(University.1, A.2.name.of.Erasmus.Mundus.master.course.,
starts_with(paste0(questions_uni[1], x)))
second_university <- course_dataset %>%
select(University.2, A.2.name.of.Erasmus.Mundus.master.course.,
starts_with(paste0(questions_uni[2], x)))
third_university <- course_dataset %>%
select(University.3, A.2.name.of.Erasmus.Mundus.master.course.,
starts_with(paste0(questions_uni[3], x)))
fourth_university <- course_dataset %>%
select(University.4, A.2.name.of.Erasmus.Mundus.master.course.,
starts_with(paste0(questions_uni[4], x)))
#since questions are always the same, binding four datasets together
z <- rbind(first_university,
setNames(second_university, names(first_university)),
setNames(third_university, names(first_university)),
setNames(fourth_university, names(first_university)))
names(z) <- gsub("the.first", "this", names(z)) #substituting "the.first" to "this" to make it gramatically correct
z <- z[!is.na(z$University.1) & z$University.1 == university,] #removing empty lines and subsetting to only chosen university
#finding out names of programs with 10 or more respondents
program_names <- z %>%
select(A.2.name.of.Erasmus.Mundus.master.course.) %>%
group_by(A.2.name.of.Erasmus.Mundus.master.course.) %>%
summarise(respondents = n()) %>%
filter(respondents >= 10)
#deleting column with university since we don't need it anymore
z$University.1 <- NULL
#leaving only names of programs with 10 or more respondents
z <- z[z$A.2.name.of.Erasmus.Mundus.master.course. %in% as.character(program_names$A.2.name.of.Erasmus.Mundus.master.course.),]
names(z)[1] <- "name"
#cleaning up names
colnames(z) <- gsub("\\.", " ", colnames(z)) #making names of questions readable
colnames(z) <- gsub("(.*?)_(.*)", "\\2", colnames(z)) #leaving just the dimension name
if(x == "5.1")
names(z) <- c("name", "Overall satisfaction in this university")
levels <- likert_levels # default is likert_levels
### making sure that levels go in order they were meant to go
for(i in 2:ncol(z)) {
### this step will also reduce all other answers to NA's
z[,i] <- factor(z[,i], levels = levels)
}
return(z)
}
prepare_university_eair("N.5.1", dataset, "University of Padua, Italy")
f <- calculatep("N.5.1", dataset, "University of Padua, Italy")
View(f)
z <- calculateallp("N.5.1", dataset, universities, method = "pvalue")
View(z)
View(z)
z[4,2] < 0.05
sum(z[4,2] < 0.05)
sum(z[4,2] < 0.05, na.rm = TRUE)
question1 <- calculateallp("N.1.1", dataset, universities, method = "pvalue")
overallsatisf <- calculatep("N.5.1", dataset, "University of Padua, Italy")
overallsatisf <- calculateallp("N.5.1", dataset, universities, method = "pvalue")
question1$sum <- colSums(question1 < 0.05, na.rm = TRUE)
question1$sum <- apply(question, MARGIN = 2, sum(., na.rm = TRUE))
question1$sum <- apply(question, MARGIN = 2, sum(na.rm = TRUE))
question1$sum <- apply(question, MARGIN = 2, sum())
question1$sum <- apply(question, MARGIN = 2, sum)
question1$sum <- apply(question1, MARGIN = 2, sum)
question1l <- question1 < 0.05
colSums(question1l)
View(question1l)
colSums(question1l, na.rm = TRUE)
question1$sum <- rowSums(question1 < 0.05, na.rm = TRUE)
View(question1)
cor(question1$sum, overallsatisf)
View(overallsatisf)
cor(question1$sum, overallsatisf[,2])
cor(question1$sum[!is.na(overallsatisf[,2])], overallsatisf[!is.na(overallsatisf[,2]),2])
overallsatisf[!is.na(overallsatisf[,2]),2]
question1 <- calculateallp("N.1.3", dataset, universities, method = "pvalue")
question1$sum <- rowSums(question1 < 0.05, na.rm = TRUE)
cor(question1$sum[!is.na(overallsatisf[,2])], overallsatisf[!is.na(overallsatisf[,2]),2])
question1 <- calculateallp("N.2.1", dataset, universities, method = "pvalue")
question1$sum <- rowSums(question1 < 0.05, na.rm = TRUE)
cor(question1$sum[!is.na(overallsatisf[,2])], overallsatisf[!is.na(overallsatisf[,2]),2])
source("functions.R")
####
universities <- dataset %>%
select(A.2.name.of.Erasmus.Mundus.master.course., University.1, University.2, University.3, University.4) %>%
melt(, id.vars = c("A.2.name.of.Erasmus.Mundus.master.course.")) %>%
select(A.2.name.of.Erasmus.Mundus.master.course., value) %>%
unique() %>%
group_by(value) %>%
tally() %>%
filter(n > 2) #change here to change how many programs should be present for further analysis
#deleting NA's
universities <- universities[complete.cases(universities),]
#dataset to check what programs were hosted by chosen university
programs <- dataset %>%
select(A.2.name.of.Erasmus.Mundus.master.course., University.1, University.2, University.3, University.4) %>%
melt(, id.vars = c("A.2.name.of.Erasmus.Mundus.master.course.")) %>%
select(A.2.name.of.Erasmus.Mundus.master.course., value) %>%
unique()
question1 <- calculateallp("N.2.1", dataset, universities, method = "pvalue")
overallsatisf <- calculateallp("N.5.1", dataset, universities, method = "pvalue")
question1$sum <- rowSums(question1 < 0.05, na.rm = TRUE)
View(question1)
hist(question1$sum)
hist(question1$sum[!is.na(overallsatisf[,2])])
View(overallsatisf)
overallsatisf <- calculateallp("N.5.1", dataset, universities, method = "mean")
cor(question1$sum[!is.na(overallsatisf[,2])], overallsatisf[!is.na(overallsatisf[,2]),2])
View(overallsatisf)
question1 <- calculateallp("N.1.1", dataset, universities, method = "pvalue")
question1$sum <- rowSums(question1 < 0.05, na.rm = TRUE)
cor(question1$sum[!is.na(overallsatisf[,2])], overallsatisf[!is.na(overallsatisf[,2]),2])
question1 <- calculateallp("N.1.3", dataset, universities, method = "pvalue")
question1$sum <- rowSums(question1 < 0.05, na.rm = TRUE)
cor(question1$sum[!is.na(overallsatisf[,2])], overallsatisf[!is.na(overallsatisf[,2]),2])
View(question1)
View(overallsatisf)
?t.test
write.csv(tenormore, "tenormore.csv")
View(question1)
question1$sum <- NULL
sum(is.na(question1))
sum(!is.na(question1))
question1$sum <- rowSums(question1 < 0.05, na.rm = TRUE)
sum(!is.na(question1[,2:ncol(question1) - 1]))
sum(question1$sum)
question1 <- calculateallp("N.1.1", dataset, universities, method = "pvalue")
question1$sum <- rowSums(question1 < 0.05, na.rm = TRUE)
sum(!is.na(question1[,2:ncol(question1) - 1]))
sum(question1$sum)
View(question1)
question1 <- calculateallp("N.2.1", dataset, universities, method = "pvalue")
question1$sum <- rowSums(question1 < 0.05, na.rm = TRUE)
sum(!is.na(question1[,2:ncol(question1) - 1]))
sum(question1$sum)
question1 <- calculateallp("N.1.1", dataset, universities, method = "pvalue")
question1$sum <- rowSums(question1 < 0.05, na.rm = TRUE)
sum(!is.na(question1[,2:ncol(question1) - 1]))
sum(question1$sum)
question2 <- calculateallp("N.1.3", dataset, universities, method = "pvalue")
question2$sum <- rowSums(question2 < 0.05, na.rm = TRUE)
sum(!is.na(question2[,2:ncol(question2) - 1]))
sum(question2$sum)
question3 <- calculateallp("N.2.1", dataset, universities, method = "pvalue")
question3$sum <- rowSums(question3 < 0.05, na.rm = TRUE)
sum(!is.na(question3[,2:ncol(question3) - 1]))
sum(question3$sum)
View(question1)
View(question2)
View(question3)
question4 <- calculateallp("N.2.2", dataset, universities, method = "pvalue")
question4 <- calculateallp("N.2.2", dataset, universities, method = "pvalue")
question4$sum <- rowSums(question4 < 0.05, na.rm = TRUE)
sum(!is.na(question4[,2:ncol(question4) - 1]))
sum(question4$sum)
View(question4)
prepare_university_eair <- function(x, course_dataset, university){
# function to prepare a dataset to use in EAIR paper
# x = name of the question
# course_dataset = dataset that needs to be prepared
# returns a dataset:
# universities with 10 or more respondents and answers to questions by respondents
questions_uni <- c("N.", "O.", "P.", "Q.") #first letters for questions about specific universities
x <- substr(x, 3, 5) #updating x to use it in a function. x in the beginning is used to make calls to functions consistent
#creating four datasets to merge them leter. Name of the university is used as an ID.
#### for paper: can add A.2.name.of.Erasmus.Mundus.master.course. to chunks and then use group_by on that variable to create other chunks
first_university <- course_dataset %>%
select(University.1, A.2.name.of.Erasmus.Mundus.master.course.,
starts_with(paste0(questions_uni[1], x)))
second_university <- course_dataset %>%
select(University.2, A.2.name.of.Erasmus.Mundus.master.course.,
starts_with(paste0(questions_uni[2], x)))
third_university <- course_dataset %>%
select(University.3, A.2.name.of.Erasmus.Mundus.master.course.,
starts_with(paste0(questions_uni[3], x)))
fourth_university <- course_dataset %>%
select(University.4, A.2.name.of.Erasmus.Mundus.master.course.,
starts_with(paste0(questions_uni[4], x)))
#since questions are always the same, binding four datasets together
z <- rbind(first_university,
setNames(second_university, names(first_university)),
setNames(third_university, names(first_university)),
setNames(fourth_university, names(first_university)))
if (x == "1.1"){
z$N.1.1.Rate.the.following.items.regarding.the.logistic.information.and.support.received.before.the.beginning.of.studies.in.the.first.university._Language.courses <- NULL
}
if (x == "1.3"){
z$N.1.3.Rate.the.introduction.process.to.the.following.units.or.people.as.part.of.the.orientation.program.at.the.first.university._Academic.staff <- NULL
z$N.1.3.Rate.the.introduction.process.to.the.following.units.or.people.as.part.of.the.orientation.program.at.the.first.university._Administrative.staff <- NULL
z$N.1.3.Rate.the.introduction.process.to.the.following.units.or.people.as.part.of.the.orientation.program.at.the.first.university._Other.students <- NULL
}
if (x == "2.1"){
z$N.2.1.Rate.the.helpfulness.of.the.following.units.of.people.at.the.first.university._Other.students <- NULL
}
names(z) <- gsub("the.first", "this", names(z)) #substituting "the.first" to "this" to make it gramatically correct
z <- z[!is.na(z$University.1) & z$University.1 == university,] #removing empty lines and subsetting to only chosen university
#finding out names of programs with 10 or more respondents
program_names <- z %>%
select(A.2.name.of.Erasmus.Mundus.master.course.) %>%
group_by(A.2.name.of.Erasmus.Mundus.master.course.) %>%
summarise(respondents = n()) %>%
filter(respondents >= 10)
#deleting column with university since we don't need it anymore
z$University.1 <- NULL
#leaving only names of programs with 10 or more respondents
z <- z[z$A.2.name.of.Erasmus.Mundus.master.course. %in% as.character(program_names$A.2.name.of.Erasmus.Mundus.master.course.),]
names(z)[1] <- "name"
#cleaning up names
colnames(z) <- gsub("\\.", " ", colnames(z)) #making names of questions readable
colnames(z) <- gsub("(.*?)_(.*)", "\\2", colnames(z)) #leaving just the dimension name
if(x == "5.1")
names(z) <- c("name", "Overall satisfaction in this university")
levels <- likert_levels # default is likert_levels
### making sure that levels go in order they were meant to go
for(i in 2:ncol(z)) {
### this step will also reduce all other answers to NA's
z[,i] <- factor(z[,i], levels = levels)
}
return(z)
}
question1 <- calculateallp("N.1.1", dataset, universities, method = "pvalue")
View(question1)
calculatep <- function(x, dataset, university, method = "pvalue"){
# function to calculate list of p-values with 95% CI for a given university
# x = name of the question
# dataset = dataset containing necessary information
# university = string with a name university
# pvalue = if TRUE, will return pvalue, if FALSE will return difference in means
# returns a vector of given length with calculated p-values. If p-value couldn't have been calculated, returns NA.
#preparing dataset to have information about only a given university
z <- prepare_university_eair(x, dataset, university)
#calculating means for all dimensions
means_question <- z %>%
group_by(name) %>%
summarise_each(funs(f1))
#preparing empty vector of given length
pvalues <- data.frame(matrix(ncol = ncol(z)))
pvalues[1] <- as.character(university) #pasting name of a university
for (i in 2:ncol(z)){
names(pvalues)[i] <- names(z)[i] #pasting name of a dimension
#calculating location of a minimum and a maximum in a column
minimum <- which.min(as.numeric(unlist(means_question[,i])))
maximum <- which.max(as.numeric(unlist(means_question[,i])))
#slicing prepared dataset to have information about program with minimal and maximum values
x <- z[z$name == means_question$name[minimum], ]
y <- z[z$name == means_question$name[maximum], ]
#catch-all condition to make sure that we calculate means only when it makes sense
#if there are less than 2 programs, if there are less than 10 observations in any of the programs, NA will be kept in a column
if(nrow(means_question) < 2 || nrow(x) < 10 || nrow(y) < 10 || sum(!is.na(means_question[,i])) == 1)
next
else {
#       if(method == "pvalue")
#         pvalues[1, i] <- t.test(as.numeric(x[,i]), as.numeric(y[,i]))$p.value
#       if (method == "mean")
#         pvalues[1, i] <- abs(mean(as.numeric(x[,i]), na.rm = TRUE) - mean(as.numeric(y[,i]), na.rm = TRUE))
temp <- t.test(as.numeric(x[,i]), as.numeric(y[,i]))$p.value
if(temp < 0.05)
pvalues[1, i] <- 3
else if (mean(as.numeric(x[,i]), na.rm = TRUE) > 3 & mean(as.numeric(y[,i]), na.rm = TRUE) > 3)
pvalues[1, i] <- 1
else if (mean(as.numeric(x[,i]), na.rm = TRUE) < 2.5 & mean(as.numeric(y[,i]), na.rm = TRUE) < 2.5)
pvalues[1, i] <- 2
else
pvalues[1, i] <- 4
}
}
return (pvalues)
}
question1 <- calculateallp("N.1.1", dataset, universities, method = "pvalue")
View(question1)
question2 <- calculateallp("N.1.3", dataset, universities, method = "pvalue")
question3 <- calculateallp("N.2.1", dataset, universities, method = "pvalue")
question4 <- calculateallp("N.2.2", dataset, universities, method = "pvalue")
View(question4)
View(question2)
View(question1)
View(question2)
View(question3)
View(question4)
table(question1[,2:ncol(question1)])
table(question1)
overallsatisf <- calculateallp("N.5.1", dataset, universities, method = "mean")
View(overallsatisf)
calculatep <- function(x, dataset, university, method = "pvalue"){
# function to calculate list of p-values with 95% CI for a given university
# x = name of the question
# dataset = dataset containing necessary information
# university = string with a name university
# pvalue = if TRUE, will return pvalue, if FALSE will return difference in means
# returns a vector of given length with calculated p-values. If p-value couldn't have been calculated, returns NA.
#preparing dataset to have information about only a given university
z <- prepare_university_eair(x, dataset, university)
#calculating means for all dimensions
means_question <- z %>%
group_by(name) %>%
summarise_each(funs(f1))
#preparing empty vector of given length
pvalues <- data.frame(matrix(ncol = ncol(z)))
pvalues[1] <- as.character(university) #pasting name of a university
for (i in 2:ncol(z)){
names(pvalues)[i] <- names(z)[i] #pasting name of a dimension
#calculating location of a minimum and a maximum in a column
minimum <- which.min(as.numeric(unlist(means_question[,i])))
maximum <- which.max(as.numeric(unlist(means_question[,i])))
#slicing prepared dataset to have information about program with minimal and maximum values
x <- z[z$name == means_question$name[minimum], ]
y <- z[z$name == means_question$name[maximum], ]
#catch-all condition to make sure that we calculate means only when it makes sense
#if there are less than 2 programs, if there are less than 10 observations in any of the programs, NA will be kept in a column
if(nrow(means_question) < 2 || nrow(x) < 10 || nrow(y) < 10 || sum(!is.na(means_question[,i])) == 1)
next
else {
#       if(method == "pvalue")
#         pvalues[1, i] <- t.test(as.numeric(x[,i]), as.numeric(y[,i]))$p.value
#       if (method == "mean")
#         pvalues[1, i] <- abs(mean(as.numeric(x[,i]), na.rm = TRUE) - mean(as.numeric(y[,i]), na.rm = TRUE))
temp <- t.test(as.numeric(x[,i]), as.numeric(y[,i]))$p.value
if(temp < 0.05)
pvalues[1, i] <- 3
else if (mean(as.numeric(x[,i]), na.rm = TRUE) > 3 & mean(as.numeric(y[,i]), na.rm = TRUE) > 3)
pvalues[1, i] <- 1
else if (mean(as.numeric(x[,i]), na.rm = TRUE) < 2.7 & mean(as.numeric(y[,i]), na.rm = TRUE) < 2.7)
pvalues[1, i] <- 2
else
pvalues[1, i] <- 4
}
}
return (pvalues)
}
question1 <- calculateallp("N.1.1", dataset, universities, method = "pvalue")
sum(!is.na(question1[,2:ncol(question1)]))
question2 <- calculateallp("N.1.3", dataset, universities, method = "pvalue")
question3 <- calculateallp("N.2.1", dataset, universities, method = "pvalue")
sum(!is.na(question3[,2:ncol(question3)]))
question4 <- calculateallp("N.2.2", dataset, universities, method = "pvalue")
sum(!is.na(question4[,2:ncol(question4)]))
View(question1)
View(question2)
View(question3)
View(question4)
calculatep <- function(x, dataset, university, method = "pvalue"){
# function to calculate list of p-values with 95% CI for a given university
# x = name of the question
# dataset = dataset containing necessary information
# university = string with a name university
# pvalue = if TRUE, will return pvalue, if FALSE will return difference in means
# returns a vector of given length with calculated p-values. If p-value couldn't have been calculated, returns NA.
#preparing dataset to have information about only a given university
z <- prepare_university_eair(x, dataset, university)
#calculating means for all dimensions
means_question <- z %>%
group_by(name) %>%
summarise_each(funs(f1))
#preparing empty vector of given length
pvalues <- data.frame(matrix(ncol = ncol(z)))
pvalues[1] <- as.character(university) #pasting name of a university
for (i in 2:ncol(z)){
names(pvalues)[i] <- names(z)[i] #pasting name of a dimension
#calculating location of a minimum and a maximum in a column
minimum <- which.min(as.numeric(unlist(means_question[,i])))
maximum <- which.max(as.numeric(unlist(means_question[,i])))
#slicing prepared dataset to have information about program with minimal and maximum values
x <- z[z$name == means_question$name[minimum], ]
y <- z[z$name == means_question$name[maximum], ]
#catch-all condition to make sure that we calculate means only when it makes sense
#if there are less than 2 programs, if there are less than 10 observations in any of the programs, NA will be kept in a column
if(nrow(means_question) < 2 || nrow(x) < 10 || nrow(y) < 10 || sum(!is.na(means_question[,i])) == 1)
next
else {
#       if(method == "pvalue")
#         pvalues[1, i] <- t.test(as.numeric(x[,i]), as.numeric(y[,i]))$p.value
#       if (method == "mean")
#         pvalues[1, i] <- abs(mean(as.numeric(x[,i]), na.rm = TRUE) - mean(as.numeric(y[,i]), na.rm = TRUE))
temp <- t.test(as.numeric(x[,i]), as.numeric(y[,i]))$p.value
if(temp < 0.05)
pvalues[1, i] <- 3
else if (mean(as.numeric(x[,i]), na.rm = TRUE) > 3 & mean(as.numeric(y[,i]), na.rm = TRUE) > 3)
pvalues[1, i] <- 1
else if (mean(as.numeric(x[,i]), na.rm = TRUE) < 3 & mean(as.numeric(y[,i]), na.rm = TRUE) < 3)
pvalues[1, i] <- 2
else
pvalues[1, i] <- 4
}
}
return (pvalues)
}
question1 <- calculateallp("N.1.1", dataset, universities, method = "pvalue")
sum(!is.na(question1[,2:ncol(question1)]))
question2 <- calculateallp("N.1.3", dataset, universities, method = "pvalue")
question3 <- calculateallp("N.2.1", dataset, universities, method = "pvalue")
sum(!is.na(question3[,2:ncol(question3)]))
question4 <- calculateallp("N.2.2", dataset, universities, method = "pvalue")
sum(!is.na(question4[,2:ncol(question4)]))
View(question1)
View(question2)
View(question3)
View(question4)
?table
table(question1[,2])
View(question1)
question1_melt <- melt(question1, id.vars = "X1")
View(question1_melt)
table(question1_melt$value)
question1 <- calculateallp("N.1.1", dataset, universities, method = "pvalue")
question1_melt <- melt(question1, id.vars = "X1")
table(question1_melt$value)
question2 <- calculateallp("N.1.3", dataset, universities, method = "pvalue")
question2_melt <- melt(question2, id.vars = "X1")
table(question2_melt$value)
question3 <- calculateallp("N.2.1", dataset, universities, method = "pvalue")
question3_melt <- melt(question3, id.vars = "X1")
table(question3_melt$value)
question4 <- calculateallp("N.2.2", dataset, universities, method = "pvalue")
question4_melt <- melt(question4, id.vars = "X1")
table(question4_melt$value)
calculatep <- function(x, dataset, university, method = "pvalue"){
# function to calculate list of p-values with 95% CI for a given university
# x = name of the question
# dataset = dataset containing necessary information
# university = string with a name university
# pvalue = if TRUE, will return pvalue, if FALSE will return difference in means
# returns a vector of given length with calculated p-values. If p-value couldn't have been calculated, returns NA.
#preparing dataset to have information about only a given university
z <- prepare_university_eair(x, dataset, university)
#calculating means for all dimensions
means_question <- z %>%
group_by(name) %>%
summarise_each(funs(f1))
#preparing empty vector of given length
pvalues <- data.frame(matrix(ncol = ncol(z)))
pvalues[1] <- as.character(university) #pasting name of a university
for (i in 2:ncol(z)){
names(pvalues)[i] <- names(z)[i] #pasting name of a dimension
#calculating location of a minimum and a maximum in a column
minimum <- which.min(as.numeric(unlist(means_question[,i])))
maximum <- which.max(as.numeric(unlist(means_question[,i])))
#slicing prepared dataset to have information about program with minimal and maximum values
x <- z[z$name == means_question$name[minimum], ]
y <- z[z$name == means_question$name[maximum], ]
#catch-all condition to make sure that we calculate means only when it makes sense
#if there are less than 2 programs, if there are less than 10 observations in any of the programs, NA will be kept in a column
if(nrow(means_question) < 2 || nrow(x) < 10 || nrow(y) < 10 || sum(!is.na(means_question[,i])) == 1)
next
else {
#       if(method == "pvalue")
#         pvalues[1, i] <- t.test(as.numeric(x[,i]), as.numeric(y[,i]))$p.value
#       if (method == "mean")
#         pvalues[1, i] <- abs(mean(as.numeric(x[,i]), na.rm = TRUE) - mean(as.numeric(y[,i]), na.rm = TRUE))
temp <- t.test(as.numeric(x[,i]), as.numeric(y[,i]))$p.value
if(temp < 0.05)
pvalues[1, i] <- 3
else if (mean(as.numeric(x[,i]), na.rm = TRUE) > 3 & mean(as.numeric(y[,i]), na.rm = TRUE) > 3)
pvalues[1, i] <- 1
else if (mean(as.numeric(x[,i]), na.rm = TRUE) < 2.5 & mean(as.numeric(y[,i]), na.rm = TRUE) < 2.5)
pvalues[1, i] <- 2
else
pvalues[1, i] <- 4
}
}
return (pvalues)
}
question1 <- calculateallp("N.1.1", dataset, universities, method = "pvalue")
question1_melt <- melt(question1, id.vars = "X1")
table(question1_melt$value)
question2 <- calculateallp("N.1.3", dataset, universities, method = "pvalue")
question2_melt <- melt(question2, id.vars = "X1")
table(question2_melt$value)
question3 <- calculateallp("N.2.1", dataset, universities, method = "pvalue")
question3_melt <- melt(question3, id.vars = "X1")
table(question3_melt$value)
question4 <- calculateallp("N.2.2", dataset, universities, method = "pvalue")
question4_melt <- melt(question4, id.vars = "X1")
table(question4_melt$value)
everydim <- rbind(question1_melt, question2_melt, question3_melt, question4_melt)
table(everydim$value)
View(question1)
source("functions.R")
####
universities <- dataset %>%
select(A.2.name.of.Erasmus.Mundus.master.course., University.1, University.2, University.3, University.4) %>%
melt(, id.vars = c("A.2.name.of.Erasmus.Mundus.master.course.")) %>%
select(A.2.name.of.Erasmus.Mundus.master.course., value) %>%
unique() %>%
group_by(value) %>%
tally() %>%
filter(n > 2) #change here to change how many programs should be present for further analysis
#deleting NA's
universities <- universities[complete.cases(universities),]
#dataset to check what programs were hosted by chosen university
programs <- dataset %>%
select(A.2.name.of.Erasmus.Mundus.master.course., University.1, University.2, University.3, University.4) %>%
melt(, id.vars = c("A.2.name.of.Erasmus.Mundus.master.course.")) %>%
select(A.2.name.of.Erasmus.Mundus.master.course., value) %>%
unique()
question1 <- calculateallp("N.1.1", dataset, universities, method = "pvalue")
question1_melt <- melt(question1, id.vars = "X1")
question2 <- calculateallp("N.1.3", dataset, universities, method = "pvalue")
question2_melt <- melt(question2, id.vars = "X1")
question3 <- calculateallp("N.2.1", dataset, universities, method = "pvalue")
question3_melt <- melt(question3, id.vars = "X1")
question4 <- calculateallp("N.2.2", dataset, universities, method = "pvalue")
question4_melt <- melt(question4, id.vars = "X1")
everydim <- rbind(question1_melt, question2_melt, question3_melt, question4_melt)
table(everydim$value)
